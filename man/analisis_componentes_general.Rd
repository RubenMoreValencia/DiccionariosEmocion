% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modelos_aprendizaje.R
\name{analisis_componentes_general}
\alias{analisis_componentes_general}
\title{Análisis de Componentes General (PCA, MFA, PLS) con visualización ggplot2}
\usage{
analisis_componentes_general(
  data,
  metodo = c("PCA", "MFA", "PLS"),
  vars_independientes,
  vars_dependientes = NULL,
  bloques = NULL,
  tipos_bloques = NULL,
  escalar = TRUE,
  n_comp = 2,
  color_by = NULL,
  label_col = NULL,
  idioma_col = NULL,
  n_labels = 200,
  label_min_r2 = 0,
  point_size = 2.2,
  label_size = 2.2,
  label_size_vars = 2.3,
  alpha_opacidad = 0.7,
  palette = c("Dark2", "Set1", "OkabeIto", "viridis"),
  show_ellipses = TRUE,
  ellipse_min_n = 3L,
  ellipse_level = 0.9,
  shape_mode = c("auto", "none", "topk"),
  shape_top_k = 6L,
  top_vars = 10,
  scale_arrows = 1.6,
  out_path = NULL
)
}
\arguments{
\item{data}{\code{data.frame}. Conjunto de datos (p.ej., \code{tokens}).}

\item{metodo}{\code{character}. Uno de \code{"PCA"}, \code{"MFA"}, \code{"PLS"}.}

\item{vars_independientes}{\code{character}. Nombres de columnas numéricas usadas como X.}

\item{vars_dependientes}{\code{character} o \code{NULL}. Para \code{PLS} (Y) o como
variables suplementarias en \code{PCA}/\code{MFA}. En \code{PLS}, si Y es factor binaria,
se convertirá a 0/1 (primera categoría = 1).}

\item{bloques}{\code{list} o \code{NULL}. Solo para \code{MFA}. Lista de vectores de
nombres de columnas por bloque (p.ej., \code{list(lex=c(...), emo=c(...))}). Alternativa:
vector de tamaños (enteros) en el orden de \code{vars_independientes}.}

\item{tipos_bloques}{\code{character} o \code{NULL}. Solo para \code{MFA}. Tipos de cada
bloque, p.ej., \code{c("s","s","n")} (ver \code{FactoMineR::MFA}).}

\item{escalar}{\code{logical}. Si \code{TRUE}, estandariza X.}

\item{n_comp}{\code{integer}. Nº de componentes/ejes a calcular (min 2; se grafican PC1 y PC2).}

\item{color_by}{\code{character} o \code{NULL}. Columna categórica para color (no entra en el ajuste).}

\item{label_col}{\code{character} o \code{NULL}. Columna con etiquetas de puntos (p.ej., \code{"token_orig"}).}

\item{idioma_col}{\code{character} o \code{NULL}. Columna categórica que puede mapearse a \emph{shape}.}

\item{n_labels}{\code{integer} o \code{NA}. Máximo de etiquetas de puntos (\code{NA} para todas).}

\item{label_min_r2}{\code{numeric}. Umbral mínimo de \eqn{PC1^2+PC2^2} para etiquetar.}

\item{point_size}{\code{numeric}. Tamaño de puntos.}

\item{label_size}{\code{numeric}. Tamaño del texto de etiquetas de individuos.}

\item{label_size_vars}{\code{numeric}. Tamaño del texto de etiquetas de variables.}

\item{alpha_opacidad}{\code{numeric} en \code{[0,1]}. Opacidad de puntos.}

\item{palette}{\code{character}. \code{"Dark2"}, \code{"Set1"}, \code{"OkabeIto"}, \code{"viridis"}.}

\item{show_ellipses}{\code{logical}. Dibuja elipses por \code{color_by} si hay suficientes puntos.}

\item{ellipse_min_n}{\code{integer}. Mínimo de puntos por grupo para elipse.}

\item{ellipse_level}{\code{numeric}. Nivel de confianza de elipse (p.ej., 0.9).}

\item{shape_mode}{\code{character}. \code{"auto"}, \code{"none"} o \code{"topk"} para manejar muchas categorías.}

\item{shape_top_k}{\code{integer}. Si \code{shape_mode="topk"}, nº máximo de shapes y el resto se agrupa en "Otros".}

\item{top_vars}{\code{integer}. Nº de variables (loadings) a mostrar (flechas) en el plano.}

\item{scale_arrows}{\code{numeric}. Factor de escala para las flechas de variables (loadings).}

\item{out_path}{\code{character} o \code{NULL}. Si no es \code{NULL}, guarda PNG en esa ruta.}
}
\value{
\code{list} con:
\itemize{
\item \code{metodo}: método usado.
\item \code{modelo}: objeto del modelo subyacente (\code{prcomp}, \code{MFA}, \code{mvr}).
\item \code{coords_ind}: \code{data.frame} con PC1/PC2 de individuos (+ columnas de color/shape/label).
\item \code{coords_var}: \code{data.frame} con loadings de variables (PC1/PC2 y magnitud).
\item \code{plot}: objeto \pkg{ggplot2}.
\item \code{path}: ruta del PNG si se guardó.
}
}
\description{
Unifica PCA, MFA y PLS bajo una sola interfaz. Permite definir variables
independientes (\code{vars_independientes}), opcionalmente variables dependientes
(\code{vars_dependientes}) y, en el caso de MFA, bloques/tipos de variables
(\code{bloques}, \code{tipos_bloques}). Devuelve coordenadas de individuos y
variables, más una figura \pkg{ggplot2} en un solo lienzo.
}
\details{
\strong{PCA}: usa \code{stats::prcomp}. \cr
\strong{MFA}: usa \code{FactoMineR::MFA}; requiere \code{bloques} y \code{tipos_bloques}. \cr
\strong{PLS}: usa \code{pls::plsr}. Si \code{vars_dependientes} es factor binaria se transforma a 0/1.
}
\examples{
\dontrun{
# Ejemplo con tokens:
tokens <- cl_res$data
feat <- seleccionar_features_tokens(tokens)

# 1) PCA puro (exploratorio)
res_pca <- analisis_componentes_general(
  data = tokens,
  metodo = "PCA",
  vars_independientes = feat,
  color_by = "cluster",
  label_col = "token_orig",
  idioma_col = "token_idioma_unico",
  shape_mode = "none",     # evita 1000 shapes
  n_labels = 200,
  palette = "OkabeIto",
  out_path = "outputs_lexico/pca_general.png"
)
print(res_pca$plot)

# 2) MFA por bloques (ejemplo: 4 léxicos + 10 emocionales)
bloques <- list(
  lex = c("syuzhet","bing","afinn","nrc"),
  emo = c("anger","anticipation","disgust","fear","joy","sadness","surprise","trust","negative","positive")
)
tipos <- c("s","s")  # ambas cuantitativas estandarizadas
res_mfa <- analisis_componentes_general(
  data = tokens,
  metodo = "MFA",
  vars_independientes = unlist(bloques),
  bloques = bloques,
  tipos_bloques = tipos,
  color_by = "cluster",
  label_col = "token_orig",
  palette = "Dark2",
  out_path = "outputs_lexico/mfa_general.png"
)
print(res_mfa$plot)

# 3) PLS (ej.: predecir valencia numérica o binaria)
# Supón que 'Nivel_bin' es factor con 2 niveles o tienes una métrica continua 'valencia_plus'
res_pls <- analisis_componentes_general(
  data = tokens,
  metodo = "PLS",
  vars_independientes = feat,
  vars_dependientes = "valencia_plus",  # o "Nivel_bin" (binaria)
  color_by = "cluster",
  label_col = "token_orig",
  palette = "Set1",
  out_path = "outputs_lexico/pls_general.png"
)
print(res_pls$plot)
}

}
\seealso{
Other DiccionariosEmocion: 
\code{\link{analizar_coherencia_metodos}()},
\code{\link{build_matrix_from_artifact}()},
\code{\link{compute_correlations}()},
\code{\link{compute_kappa}()},
\code{\link{cronbach_alpha}()},
\code{\link{evaluar_con_artefacto}()},
\code{\link{features_canonicas}()},
\code{\link{guardar_artefacto_modelos}()},
\code{\link{normalizar_emociones}()},
\code{\link{predecir_con_artefacto}()},
\code{\link{prep_emotions_data}()},
\code{\link{preparar_features_tokens}()}
}
\concept{DiccionariosEmocion}
