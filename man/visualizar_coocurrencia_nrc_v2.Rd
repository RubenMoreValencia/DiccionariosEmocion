% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/visualizacion_modelos.R
\name{visualizar_coocurrencia_nrc_v2}
\alias{visualizar_coocurrencia_nrc_v2}
\title{Visualizar co-ocurrencia NRC (heatmap o red) con color por comunidad/grado}
\usage{
visualizar_coocurrencia_nrc_v2(
  matriz,
  tipo = c("heatmap", "red"),
  normalizar = c("none", "prop", "max"),
  diag_cero = TRUE,
  ordenar = c("hclust", "sum", "none"),
  palette = NULL,
  min_edge = 0,
  top_edges = NULL,
  layout_red = c("fr", "kk", "dh", "lgl", "graphopt", "mds"),
  color_nodes = c("none", "community", "degree"),
  community_method = c("louvain", "walktrap", "infomap"),
  node_palette = NULL,
  remove_isolated = TRUE,
  seed = NULL
)
}
\arguments{
\item{matriz}{(auto) TODO: describir parámetro.}

\item{tipo}{(auto) TODO: describir parámetro.}

\item{normalizar}{\code{c("none","prop","max")}. \code{"prop"} divide por la suma total;
\code{"max"} divide por el valor máximo; \code{"none"} no normaliza. Por defecto \code{"none"}.}

\item{diag_cero}{\code{logical}. Si \code{TRUE}, pone la diagonal en 0 (evita auto-coocurrencia).
Por defecto \code{TRUE}.}

\item{ordenar}{\code{c("none","sum","hclust")}. Reordena emociones por suma decreciente o clustering
jerárquico (\code{hclust}) sobre la matriz simétrica. Por defecto \code{"hclust"}.}

\item{palette}{\code{character} o vector de colores. Si \code{NULL}, usa \code{viridis}.}

\item{min_edge}{\code{numeric}. Umbral mínimo de peso de arista para la red (excluye menores).
Por defecto \code{0}.}

\item{top_edges}{\code{integer} opcional. Si se indica, mantiene solo las \code{top_edges} aristas
más pesadas (tras aplicar \code{min_edge}).}

\item{layout_red}{\code{character}. Layout de \pkg{ggraph} para la red. Por defecto \code{"fr"}.}

\item{color_nodes}{\code{c("none","community","degree")}. Cómo colorear nodos en la red.}

\item{community_method}{\code{c("louvain","walktrap","infomap")}. Algoritmo de comunidad.}

\item{node_palette}{Vector de colores (si \code{color_nodes="community"}) o nombre de paleta viridis.}

\item{remove_isolated}{\code{logical}. Si \code{TRUE}, elimina nodos aislados tras filtro de aristas.}

\item{seed}{\code{integer} para reproducibilidad del layout.}

\item{"red"}{(auto) TODO: describir parámetro.}
}
\value{
Lista con matriz procesada, edges, y \code{grafico}. Si \code{color_nodes="community"},
devuelve además \code{comunidades} (vector por nodo).
}
\description{
Extiende la visualización a red con: color de nodos por \strong{comunidad} (Louvain/Walktrap/Infomap)
o \strong{grado}, layouts alternativos y opciones de filtrado de aristas. Mantiene el modo heatmap.
}
\examples{
\dontrun{
# Red con color por comunidad (Louvain) y layout de Kamada-Kawai
v2c <- visualizar_coocurrencia_nrc_v2(
  cooc, tipo = "red", normalizar = "max",
  min_edge = 0.05, top_edges = 60,
  color_nodes = "community", community_method = "louvain",
  layout_red = "kk", seed = 123
)
print(v2c$grafico)

# Red coloreando por grado y layout de Fruchterman-Reingold
v2d <- visualizar_coocurrencia_nrc_v2(
  cooc, tipo = "red", normalizar = "prop",
  color_nodes = "degree", layout_red = "fr", seed = 42
)
print(v2d$grafico)
}
}
\seealso{
Other matrices_valoradas: 
\code{\link{MatrizValoradaXMetodo}()},
\code{\link{visualizar_coocurrencia_nrc}()},
\code{\link{visualizar_emociones_nrc}()}
}
\concept{matrices_valoradas}
