% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modelos_aprendizaje.R
\name{validar_binario_con_split}
\alias{validar_binario_con_split}
\title{Validación binaria con split (estratificado o por grupo) y calibración}
\usage{
validar_binario_con_split(
  tokens,
  target,
  features = NULL,
  modelos = c("rf", "svmRadial", "glmnet"),
  p_train = 0.8,
  seed = 801,
  out_dir = "outputs_lexico/validacion_bin",
  positive_label = NULL,
  sampling = NULL,
  split_by = NULL,
  calibr_bins = 10
)
}
\arguments{
\item{tokens}{\code{data.frame}. Datos a nivel token que contienen \code{target} y \code{features}.}

\item{target}{\code{character}. Nombre de la columna binaria objetivo (factor con 2 niveles).}

\item{features}{\code{character} o \code{NULL}. Nombres de columnas predictoras a usar;
si es \code{NULL}, se intenta seleccionarlas con \code{seleccionar_features_tokens()}.}

\item{modelos}{\code{character}. Métodos a entrenar (por ejemplo, \code{c("rf","svmRadial","glmnet")}).}

\item{p_train}{\code{numeric} en \code{(0,1)}. Proporción para el conjunto de entrenamiento.}

\item{seed}{\code{numeric}. Semilla para reproducibilidad.}

\item{out_dir}{\code{character} o \code{NULL}. Carpeta de salida para artefactos; si es \code{NULL},
no se guardan gráficos ni tablas en disco.}

\item{positive_label}{\code{character} o \code{NULL}. Etiqueta positiva del \code{target} para métricas;
si es \code{NULL}, se infiere con \code{make.names()} o se usa el nivel por defecto.}

\item{sampling}{\code{character} o \code{NULL}. Estrategia de muestreo en \code{caret} (\code{"smote"},
\code{"up"}, \code{"down"}); si es \code{NULL}, no se aplica balanceo.}

\item{split_by}{\code{character} o \code{NULL}. Columna para split por grupos; si es \code{NULL},
se realiza partición estratificada estándar.}

\item{calibr_bins}{\code{integer}. Número de bins para la evaluación de calibración.}
}
\value{
Una \code{list} con:
\code{fits} (modelos \code{caret}),
\code{metrics_cv} (métricas de CV),
\code{metrics_tst_050} (métricas en \code{TEST} con umbral 0.5),
\code{metrics_tst_thr} (métricas en \code{TEST} con umbral óptimo por modelo),
\code{thresholds} (umbrales óptimos por modelo),
\code{brier} (Brier score por modelo),
\code{split_idx} (índices \code{train}/\code{test}),
\code{paths} (rutas de los gráficos guardados, si \code{out_dir} no es \code{NULL}),
\code{dummy_recipe} (objeto \code{caret::dummyVars} para reproducir el preprocesamiento).
}
\description{
Realiza una validación basada en una partición \code{train/test} para un problema
binario a nivel token, entrenando varios modelos y comparando métricas. Incluye
umbralización, cálculo de \code{ROC AUC}, \code{Brier score} y, opcionalmente,
calibración por bins.
}
\details{
Si \code{split_by} no es \code{NULL}, se hace partición por grupos (por ejemplo,
por \code{"token_idioma_unico"}) para evitar fuga de información entre \code{train}
y \code{test}. El argumento \code{sampling} admite \code{"smote"}, \code{"up"} o
\code{"down"} para balanceo en \code{caret}. Cuando \code{out_dir} no es \code{NULL},
se guardan al disco las curvas ROC, calibración y matrices de confusión.
}
\examples{
\dontrun{
# Selección explícita de features
features <- c("anger","anticipation","disgust","fear","joy","sadness",
              "surprise","trust","negative","positive",
              "Nivel_syuzhet","Nivel_bing","Nivel_afinn","Nivel_nrc")

res_val <- validar_binario_con_split(
  tokens  = res_p1$data,
  target  = "Nivel_bin",
  features = features,
  modelos = c("rf","svmRadial","glmnet"),
  p_train = 0.8, seed = 801,
  out_dir = "outputs_lexico/validacion_bin",
  positive_label = "Pos",
  sampling = NULL, split_by = NULL, calibr_bins = 10
)
res_val$metrics_tst_050
res_val$metrics_tst_thr
}

}
\seealso{
\code{caret::train}, \code{caret::createDataPartition}, \code{caret::confusionMatrix},
\code{pROC::roc}, \code{pROC::auc}
}
