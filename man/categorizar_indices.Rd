% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/etiquetado_sentimiento.R
\name{categorizar_indices}
\alias{categorizar_indices}
\title{Categorización por percentiles de columnas (y/o índice agregado) con soporte de pesos y escalado}
\usage{
categorizar_indices(
  df,
  idx,
  prefix = "Cat_",
  mode = c("per_column", "aggregate", "both"),
  weights = NULL,
  scale_method = c("auto", "zscore", "range", "robust", "none"),
  aggregate_name = "indice",
  probs = c(0.25, 0.5, 0.75),
  labels = NULL,
  include_lowest = TRUE,
  right = FALSE,
  na.rm = TRUE
)
}
\arguments{
\item{df}{data.frame con columnas numéricas a procesar.}

\item{idx}{Integer o character. Columnas a categorizar (por nombre o posición).}

\item{prefix}{Character. Prefijo para las nuevas columnas categóricas. Default \code{"Cat_"}.}

\item{mode}{Character. \code{"per_column"} (default) para categorizar cada columna por separado;
\code{"aggregate"} para crear un índice agregado y categorizarlo; \code{"both"} para hacer ambos.}

\item{weights}{Numeric o NULL. Pesos para las columnas cuando \code{mode} incluye \code{"aggregate"}.
Si \code{NULL}, se asume iguales. Debe coincidir con \code{length(idx)}.}

\item{scale_method}{Character. Escalado previo al agregado: \code{"auto"} (default, z-score),
\code{"zscore"}, \code{"range"} (min-max), \code{"robust"} (mediana/MAD), \code{"none"}.}

\item{aggregate_name}{Character. Nombre de la columna del índice agregado (sin prefijo).
Default \code{"indice"}.}

\item{probs, labels, include_lowest, right, na.rm}{Pasados a \code{categorizar_por_percentiles()}.}

\item{"aggregate"}{(auto) TODO: describir parámetro.}

\item{"both"}{(auto) TODO: describir parámetro.}
}
\value{
list con:
\itemize{
\item \code{data}: data.frame original + columnas categorizadas añadidas.
\item \code{meta}: lista con \code{breaks} y \code{probs_usados} por cada salida creada.
}
}
\description{
Dadas columnas numéricas de un data.frame, categoriza por percentiles cada columna
(modo "per_column") y opcionalmente construye un \strong{índice agregado} con pesos
y escalado (modo "aggregate"). Usa internamente \code{categorizar_por_percentiles()}.
}
\examples{
# Suponiendo dfx_es con métodos léxicos en columnas 11:14 (syuzhet, bing, afinn, nrc):
# 1) Categorizar cada método por separado
res1 <- categorizar_indices(
  df = dfx_es, idx = 11:14, prefix = "Cat_", mode = "per_column"
)
names(res1$data)

# 2) Índice agregado (zscore + pesos) y categorización
res2 <- categorizar_indices(
  df = dfx_es, idx = c("syuzhet","bing","afinn","nrc"),
  mode = "aggregate", weights = c(0.25,0.25,0.25,0.25),
  scale_method = "zscore", aggregate_name = "polaridad"
)
table(res2$data$Cat_polaridad)

# 3) Ambos: por columna + índice agregado
res3 <- categorizar_indices(
  df = dfx_es, idx = 11:14, mode = "both",
  weights = c(0.4,0.1,0.3,0.2), scale_method = "robust",
  aggregate_name = "mix"
)
str(res3$meta)

}
\seealso{
Other utilidades: 
\code{\link{DividirPorPercentiles}()},
\code{\link{GenerarDataframeT}()},
\code{\link{LimpiaTexto}()},
\code{\link{TabContingencia_MaxMinXFila}()},
\code{\link{TraduceA}()},
\code{\link{UnirExcelITFF_Optimizada}()},
\code{\link{agregar_recuento_filas}()},
\code{\link{agrupar_emociones}()},
\code{\link{ajustar_gradient_boosting}()},
\code{\link{ajustar_red_nn_unificada}()},
\code{\link{ajustar_regresion_multinomial}()},
\code{\link{ajustar_rnn_regresion}()},
\code{\link{ajustar_rnn_regresion_torch}()},
\code{\link{analizar_coherencia_metodos}()},
\code{\link{analizar_comentarios}()},
\code{\link{analizar_comentarios_ReEscalado}()},
\code{\link{analizar_comentarios_ReEscalado_general}()},
\code{\link{analizar_comentarios_ReEscalado_v3}()},
\code{\link{analizar_comentarios_XP}()},
\code{\link{analizar_consistencia_lexicos}()},
\code{\link{analizar_consistencia_lexicos_v2}()},
\code{\link{analizar_correlaciones_metodos}()},
\code{\link{analizar_emociones_texto}()},
\code{\link{analizar_percentiles_columna}()},
\code{\link{analizar_percentiles_columnaBinaria}()},
\code{\link{analizar_tokens_extremos}()},
\code{\link{anotar_tokens_idioma_simple}()},
\code{\link{as_df_safe}()},
\code{\link{build_emotion_indices}()},
\code{\link{calcular_ensamble_ponderado}()},
\code{\link{calcular_puntaje_emocional}()},
\code{\link{calibrar_metodo_referencia}()},
\code{\link{cambiar_nombres_columnas}()},
\code{\link{categorizar_por_percentiles}()},
\code{\link{categorizar_por_percentiles_full}()},
\code{\link{cluster_emotion_spaces}()},
\code{\link{cluster_hclust_cut}()},
\code{\link{cluster_kmeans_auto}()},
\code{\link{configurar_openai_clave}()},
\code{\link{convertir_a_factores_arbol}()},
\code{\link{crear_diccionario_emociones}()},
\code{\link{eliminar_filas_repetidas}()},
\code{\link{eliminarduplicados}()},
\code{\link{emocion_mas_fuerte}()},
\code{\link{estrategia_p1_preparacion}()},
\code{\link{estrategia_p3_ensamble}()},
\code{\link{estrategia_p5_clusters}()},
\code{\link{extraer_features_emocionales}()},
\code{\link{filtrar_diccionario}()},
\code{\link{generar_reporte_html}()},
\code{\link{guardarDataFrameCSV}()},
\code{\link{interseccionDataFrames}()},
\code{\link{leerCSVConNombres}()},
\code{\link{mostrar_diccionario_emociones}()},
\code{\link{p7_exportar_reporte_maestro}()},
\code{\link{pipeline_emociones}()},
\code{\link{predecir_nivel_bin}()},
\code{\link{procesar_emociones_comentarios}()},
\code{\link{run_fa}()},
\code{\link{safe_write_csv}()},
\code{\link{segmentar_consistencia_lexicos}()},
\code{\link{simular_arbol}()},
\code{\link{simular_comparacion_todos}()},
\code{\link{simular_random_forest}()},
\code{\link{simular_red_neuronal}()},
\code{\link{simular_red_nn_unificada}()},
\code{\link{simular_regresion}()},
\code{\link{simular_regresion_multinomial}()},
\code{\link{simular_rnn_regresion}()},
\code{\link{simular_rnn_regresion_torch}()},
\code{\link{sp_save}()},
\code{\link{summarize_emotion_space}()},
\code{\link{vector_a_cadena}()},
\code{\link{verificar_clave_openai}()}
}
\concept{utilidades}
